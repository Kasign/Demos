//
//  main.m
//  多种算法研究
//
//  Created by Qiushan on 2020/9/8.
//  Copyright © 2020 FLY. All rights reserved.
//

#import <Foundation/Foundation.h>

/**
 啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。
 
 
 啥叫「自底向上」？反过来，我们直接从 【最底下】，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。
 */

#pragma mark - 动态规划问题
/**
 1、状态
 2、状态转移方程
 */

int GetMin2(int i, int j) {
    return i < j ? i : j;
}

int GetMax2(int i, int j) {
    return i > j ? i : j;
}

int GetMin3(int i, int j, int k) {
    return GetMin2(i, GetMin2(k, j));
}

int GetMax3(int i, int j, int k) {
    return GetMax2(i, GetMax2(k, j));
}

/**1、最长非降子序列的长度*/
//题：如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元
void GetMinConine() {
    
    int dp[12] = {0};//状态表示，用d(i)=j来表示凑够i元最少需要j个硬币
    int inf = 100; //表示无效值，这里可以取一个很大的值
    //dp[0]默认为0
    for (int i = 1; i <= 11; i++) {
        dp[i] = GetMin3(i - 1 >= 0 ? dp[i-1] + 1 : inf,
                        i - 3 >= 0 ? dp[i-3] + 1 : inf,
                        i - 5 >= 0 ? dp[i-5] + 1 : inf);
    }//dp[11]即为所求
    printf("%d", dp[11]);
}

/**2、二维的DP问题*/

//题：平面上有N*M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来，这样下去，你最多能收集到多少个苹果？

/**
 思路：
 
 解这个问题与解其它的DP问题几乎没有什么两样。第一步找到问题的“状态”， 第二步找到“状态转移方程”，然后基本上问题就解决了。
 
 首先，我们要找到这个问题中的“状态”是什么？我们必须注意到的一点是，到达一个格子的方式最多只有两种：从左边来的(除了第一列)和从上边来的(除了第一行)。 因此为了求出到达当前格子后最多能收集到多少个苹果，我们就要先去考察那些能到达当前这个格子的格子，到达它们最多能收集到多少个苹果。 (是不是有点绕，但这句话的本质其实是DP的关键：欲求问题的解，先要去求子问题的解)
 经过上面的分析，很容易可以得出问题的状态和状态转移方程。状态S[i][j]表示我们走到(i, j)这个格子时，最多能收集到多少个苹果。那么，状态转移方程如下：
 S[i][j] = A[i][j] + max(S[i-1][j], if i>0 ; S[i][j-1], if j>0)
 其中i代表行，j代表列，下标均从0开始；A[i][j]代表格子(i, j)处的苹果数量。
 S[i][j]有两种计算方式：1.对于每一行，从左向右计算，然后从上到下逐行处理；2. 对于每一列，从上到下计算，然后从左向右逐列处理。 这样做的目的是为了在计算S[i][j]时，S[i-1][j]和S[i][j-1]都已经计算出来了。
 */
void GetMaxApples() {
    
    int a[5][4] = {
        {1,2,3,2},
        {3,4,1,3},
        {1,2,9,6},
        {3,6,1,8},
        {2,5,4,3}};
    
    int dp[5][4] = {0};
    int row    = 5;
    int column = 4;
    for (int i = 0; i < row; i ++) {
        for (int j = 0; j < column; j ++) {
            dp[i][j] = a[i][j] + GetMax2(i > 0 ? dp[i - 1][j] : 0, j > 0 ? dp[i][j - 1] : 0);
        }
    }
    //最大的肯定是最后一个
    printf("max : %d\n", dp[row - 1][column - 1]);
}

/**3、背包问题*/
//题：话说有一哥们去森林里玩发现了一堆宝石，他数了数，一共有n个。 但他身上能装宝石的就只有一个背包，背包的容量为C。这哥们把n个宝石排成一排并编上号： 0,1,2,…,n-1。第i个宝石对应的体积和价值分别为V[i]和W[i] 。排好后这哥们开始思考： 背包总共也就只能装下体积为C的东西，那我要装下哪些宝石才能让我获得最大的利益呢？

/**
 
 思路：
 
 让我们先实例化上面的问题。一般遇到n，你就果断地给n赋予一个很小的数， 比如n=3。然后设背包容量C=10，三个宝石的体积为5，4，3，对应的价值为20，10，12。 对于这个例子，我想智商大于0的人都知道正解应该是把体积为5和3的宝石装到背包里， 此时对应的价值是20+12=32。接下来，我们把第三个宝石拿走， 同时背包容量减去第三个宝石的体积（因为它是装入背包的宝石之一）， 于是问题的各参数变为：n=2，C=7，体积｛5，4｝，价值｛20，10｝。好了， 现在这个问题的解是什么？我想智商等于0的也解得出了：把体积为5的宝石放入背包 （然后剩下体积2，装不下第二个宝石，只能眼睁睁看着它溜走），此时价值为20。 这样一来，我们发现，n=3时，放入背包的是0号和2号宝石；当n=2时， 我们放入的是0号宝石。这并不是一个偶然，没错， 这就是传说中的“全局最优解包含局部最优解”（n=2是n=3情况的一个局部子问题）。 绕了那么大的圈子，你可能要问，这都哪跟哪啊？说好的状态呢？说好的状态转移方程呢？ 别急，它们已经呼之欲出了。

 我们再把上面的例子理一下。当n=2时，我们要求的是前2个宝石， 装到体积为7的背包里能达到的最大价值；当n=3时，我们要求的是前3个宝石， 装到体积为10的背包里能达到的最大价值。有没有发现它们其实是一个句式！OK， 让我们形式化地表示一下它们， 定义d(i,j)为前i个宝石装到剩余体积为j的背包里能达到的最大价值。 那么上面两句话即为：d(2, 7)和d(3, 10)。这样看着真是爽多了， 而这两个看着很爽的符号就是我们要找的状态了。 即状态d(i,j)表示前i个宝石装到剩余体积为j的背包里能达到的最大价值。 上面那么多的文字，用一句话概括就是：根据子问题定义状态！你找到子问题， 状态也就浮出水面了。而我们最终要求解的最大价值即为d(n, C)：前n个宝石 （0,1,2…,n-1）装入剩余容量为C的背包中的最大价值。状态好不容易找到了， 状态转移方程呢？顾名思义，状态转移方程就是描述状态是怎么转移的方程（好废话！）。 那么回到例子，d(2, 7)和d(3, 10)是怎么转移的？来，我们来说说2号宝石 （记住宝石编号是从0开始的）。从d(2, 7)到d(3, 10)就隔了这个2号宝石。 它有两种情况，装或者不装入背包。如果装入，在面对前2个宝石时，背包就只剩下体积7来装它们，而相应的要加上2号宝石的价值12， d(3, 10)=d(2, 10-3)+12=d(2, 7)+12；如果不装入，体积仍为10，价值自然不变了， d(3, 10)=d(2, 10)。记住，d(3, 10)表示的是前3个宝石装入到剩余体积为10 的背包里能达到的最大价值，既然是最大价值，就有d(3, 10)=max{ d(2, 10), d(2, 7)+12 }。
 好了，这条方程描述了状态d(i, j)的一些关系， 没错，它就是状态转移方程了。把它形式化一下：d(i, j)=max{ d(i-1, j), d(i-1,j-V[i-1]) + W[i-1] }。注意讨论前i个宝石装入背包的时候， 其实是在考查第i-1个宝石装不装入背包（因为宝石是从0开始编号的）。至此， 状态和状态转移方程都已经有了。
 */
void GetMaxBags() {
    
    int vs[] = {3, 4, 3, 3};//宝石体积
    int ws[] = {18, 10, 12, 15};//宝石重量
    int bagVolume = 10;//背包体积
    
    //状态dp[i][j]表示将前i个宝石装入剩余体积为j的背包中所能获取的最大价值（应该是前 i - 1个宝石）
    //状态转移方程为：vs[i]第i个宝石的体积，ws[i]第i个宝石的价值
    //dp[i][j] = max{dp[i-1][j](不装入背包),dp[i-1][j-vs[i]]+ws[i](装入)};
    int dp[5][11] = {0};
    int row = 4;
    //背包体积，要求在体积范围内装入价值最多的宝石
    int column = bagVolume;
    
    for (int i = 0; i <= row; i ++) {
        for (int j = 0; j <= bagVolume; j++) {
            //初始化第一行
            if (i == 0) {//前0个宝石，自然为0
                break;
            }
            //当前背包剩余体积可以装下第i个宝石。
            //vs[i-1]表示第i个宝石的体积，下标从0开始
            if (j >= vs[i-1]) {
                dp[i][j] = GetMax2(dp[i-1][j], dp[i-1][j - vs[i - 1]] + ws[i-1]);
                //这里决定的是，是否放入之前的宝石
            }
        }
    }
    
    printf("max: %d", dp[row][column]);
    printf("\n");
    printf("\n");
    
    //扩展
    //打印出装入背包的标记 1 为装入 0 为未装入
    //标记装入背包的宝石
    int book[4] = {0};
    int j = bagVolume;
    for (int i = row; i > 0; i --) {
        if (dp[i][j] > dp[i-1][j]) {
            book[i-1] = 1;
            j = j - vs[i-1];
        }
    }
    
    for (int i = 0; i < 4; i++) {
        printf("%-3d ",book[i]);
    }
    printf("\n");
}

/**
 4、斐波那契数列
 int fib(int N) {
     if (N == 1 || N == 2) return 1;
     return fib(N - 1) + fib(N - 2);
 }
 */

//状态压缩 ： 简化压缩空间
void Fib(int n) {
    
    int prev = 1;
    int curr = 1;
    for (int i = 3; i <= n; i ++) {
        int sum = prev + curr;
        prev = curr;
        curr = sum;
    }
    
    printf("result: %d\n", curr);
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
//        GetMinConine();
//        GetMaxApples();
//        GetMaxBags();
        Fib(3);
        
        NSLog(@"Hello, World!");
    }
    return 0;
}



